1.
[문제]
/*무한루프 발생원인 : setQuery로 검색어 한 글자 입력시 마다 계속 해서 호출됨.*/
ProfileContainer에서 onChange={(e) => setQuery(e.target.value)} 
검색어 한 자 한 자 검색 마다 set함수로 상태가 변화하고 이 때문에 컴포넌트를 렌더링 시킴 
-> 이 문제를 해결하기 위해 'Debounce' 로 앱의 검색 기능을 향상 할 수 있음 

[해결]
1. Debounce - 일정 시간동안 발생한 이벤트 중 마지막만 실행 / 정해둔 시간 이후에 검색 하게 되면 다시 문제 발생  
2. query 값을 useState() 로 관리 하지 않고 useRef를 사용하여 들어오는 값을 참조한다.
3. input 태그에서 enter를 눌렸을 때만 이벤트 함수 call 
    onKeyDown={(e) => e.key === 'Enter' && handleSearch()}

2.
[문제]
ProfileContainer 컴포넌트 - roomsAndChats 패칭 이슈 
- Chat 컴포넌트로 부터 prop으로 받은 roomsAndChats은 async 로 가지고 오는데이터 이다.
그래서 앱을 실행했을 때 roomsAndChats값이 []로 설정되어 ProfileContainer에서 map()을 사용할 수 없다는 오류가 지속적으로 발생 

[해결]
컴포넌트의 상단부에 
    // async에서roomsAndChats 갖고 오는데 시간이 걸리기 때문에 없으면 에러남
    if (!rooms || !lastMessages) {
        return <div>Loading...</div>; // Or any loading spinner
    }
를 추가하여 roomsAndChts값을 로딩 해올 때 까지 아래의 함수들을 호출하지 않으므로 에러 발생을 막음 

혹은 useQuery 를 사용해서 enabled: '조건'을 설정해주는 방법으로 queryFn 을 실행시키고, isLoading, isError, data를 통해 조건에 맞는 jsx렌더링을 실행할 수 있다다

3.
[문제]
'클릭한 대화창의 대화기록 가져오기'를를 구현 할 때 
room 스키마가 chat을 id로 저장하고 있어서 이 id를 이용해서 chat 객체를를 어떻게 가지고 올 지 막막함 

const chatInRooms = rooms.map((room) => room.chats); 

결과: 
chatInRooms: [
  [
    new ObjectId('6757d13094356e5a4a8f923b'),
    new ObjectId('67586091e1e12051a8d80537')
  ]
]

이렇게 중첩된 list array 안에 값이 들어있어서 이 값으로 Chat.findById(chatInRooms)
를 하기 위해 우선적으로 chatInRooms을 콘솔로 찍어봤을 때 값이 잘 나오는지 부터 확인이 필요했음 
확인 결과 undefined(너무 당연함 nested array 이슈로 형변환이 필요)

그래서 flat()으로 single array 만 남기고 map()을 이용해 id 타입을 String으로 바꿔주었다 

['6757d13094356e5a4a8f923b', '67586091e1e12051a8d80537'] 이런 결과가 나올 수 있도록

[해결]

const chatIds = chatInRooms.flat().map((id) => id.toString());


4.
[문제]
2개 이상이 되는 데이터를 findById로 찾는법 
[해결]
const chats = await Chat.find({'_id': { $in: chatIdsList }});

5.
[문제]
[{1}, {2}] array list안에 있는 데이터를 원하는 형식으로 가공하기 
[해결]
map()사용
  const conversations = chats.map((chat) =>  {
    return {
      content: chat.chat,
      senderProfileImage: chat.sender.profileImage,
      senderName: chat.sender.name,
      recipientProfileImage: chat.recipient.profileImage,
      recipientName: chat.recipient.name,
      state: chat.isRead,
      createdAt: chat.createdAt,
    };
  });

  위의 결과를 시각적으로 표현하면 : conversations:[
          {
            content: 'Hi Lucy, how are you doing',
            senderProfileImage: '/uploads/1733121730891-ì\x98¤ë¹\x84ì\x84\x9C.jpg',
            senderName: 'maximilian',
            recipientProfileImage: '/uploads/1733101504620-lucy.png',
            recipientName: 'lucy',
            state: false,
            createdAt: 2024-12-10T05:27:12.432Z
          },
          {
            content: 'goodnight !',
            senderProfileImage: '/uploads/1733121730891-ì\x98¤ë¹\x84ì\x84\x9C.jpg',    senderName: 'maximilian',
            recipientProfileImage: '/uploads/1733101504620-lucy.png',
            recipientName: 'lucy',
            state: false,
            createdAt: 2024-12-10T15:38:57.919Z
          }
          ]

6.
[문제]
이메일/유저 이름으로 찾기 - gmail 이나 도메인과 일치하는 단어가 하나라도 있는경우까지 모두 보여주고 있어서 이름으로 찾기로 변경 
(기존- 이메일,유저 정보를 모두 활용해서 유저찾기)
users = await User.find({
    $or: [
        { name: { $regex: new RegExp(query, 'i')} },
        { email: { $regex: new RegExp(query, 'i')} }
    ]
});
[해결]
  //이름으로만 찾기
  users = await User.find({ name: { $regex: new RegExp(query, 'i')} });

[대소문자 구분 두지 않기기]
 /*new RegExp(query, 'i'):
  This is the correct way to create a regular expression in JavaScript.
  The RegExp constructor allows you to dynamically create a regular expression from the string query.
  The 'i' flag makes the regex case-insensitive, meaning it will match "lucy", "Lucy", "LUCY", etc.
  This is how MongoDB expects to receive regular expressions with flags. */


7.
[문제]
asynchronous로 패칭되어오는 data가 준비되지 않은 상태에서 해당 데이터를 사용하는 컴포넌트가 먼저 렌더링 되면서 
data: undefined || null 에러 발생하는 이슈 
[해결]
    const { rooms, lastMessages } = roomsAndChats;

    if (!rooms || !lastMessages) {
        return <div>Loading...</div>; // Or any loading spinner
    }
패칭되어야 하는 데이터가 패칭된 이 후에 다음 함수들을 실행 할 수 있도록 컴포넌트 상단에 이 식을 정의한다. 



----------------------------------enormous one : took about more than 2weeks----------------------------------

여러개의 데이터를 Props로 부모컴포넌트에서 하나의 자식 컴포넌트에 넘겨줬을 때 발생하는 에러에 대한 대책에 대해 알고싶습니다. 

[문제]
ProfileContainer라는 컴포넌트는 3가지 조건에 따라 PreviewCard라는 컴포넌트를 이용해 데이터를 화면에 보여주는 역할을 합니다.
하지만 3개의 조건에 따라 props를 따로 보낸다고 하더라도 이 props를 처리하는 컴포넌트는 PreviewCard라는 한 개이기 때문에 여기서 각 조건에 따라 데이터를 패칭할 때 생길 수 있는 에러를 
어떻게 해결하면 되는지에 대해서 방안을 찾고자 합니다.

우선 3개의 조건에 따라 PreviewCard 컴포넌트를 렌더링 하기위한 코드는 아래 처럼 작성되었습니다.

1. default 값: 로그인한 user의 id값을 이용해 user가 member로서 존재하는 모든 rooms를 data로 가지고 옵니다.
{!searchbarActive && combined && combined.length > 0 && (
                    <>
                        {combined.map((roomWithChat) => (
                            <PreviewCard
                                key={roomWithChat._id}
                                id={roomWithChat._id}
                                profileImage={roomWithChat.chat.profileImage}
                                name={roomWithChat.chat.name}
                                chat={roomWithChat.chat.content}
                                createdAt={roomWithChat.chat.createdAt}
                                handleChatClick={handleChatClick}
                                searchbarActive={searchbarActive}
                            />
                        ))}
                    </>
                ) }

combined 데이터를 추출하는 과정 
  const { rooms, lastMessages } = roomsAndChats;

    if (!rooms || !lastMessages) {
        return <div>Loading...</div>; // Or any loading spinner
    }

    // Combine rooms and chats (lastMessages) 채팅방- 마지막메세지가 있는 경우 
    const combined = rooms.map((room) => {
        const roomChats = lastMessages.filter((lastMessage) => lastMessage.room === room._id);
        // If we have chats, get the latest one (or first one in array)
        const latestChat = roomChats.length > 0 ? roomChats[0] : null;

        // Create a chat object with relevant properties
        const chat = latestChat ? {
            profileImage: latestChat.sender.profileImage,
            name: latestChat.sender.name,
            content: latestChat.chat,
            createdAt: latestChat.createdAt
        } : {
            profileImage: '',
            name: '',
            content: '',
            createdAt: ''
        };
        // Return room combined with chat information
        return { ...room, chat };
    });

roomsAndChats데이터로 응답하는 서버 코드 
chatController.getChatMessagesByRoom = async (req, res) => {
    try {
    const userId = req.userId;

    if(!userId){
        return res.status(404).json({message: 'getChatMessagesByRoom - no user ID is fetched.'})
    }

    const rooms = await Room.find({members : userId});
      if (!rooms) {
        return res.status(404).json({ message: 'getChatMessagesByRoom - Rooms not found' });
      }
      const lastMessages = await Promise.all(
        rooms.map(async (room) => {
          const lastMessageIdx = room.chats.slice(-1)[0];

          if(lastMessageIdx) {
            const lastMessage = await Chat.findById(lastMessageIdx);
            return lastMessage;
          }
          return null; 
        })
      );
      return res.json({rooms, lastMessages}); // return res.json(rooms); 
    } catch (e) {
      console.error('Failed to fetch chat messages', e);
      return res.status(500).json({ message: 'Failed to fetch chat messages' });
    }
  };
  
  이렇게 전달된 rooms와lastMessages 데이터는 ProfileContainer의 부모 컴포넌트인 Chat 컴포넌트가 실행될 때 
  useEffect를 통해서 
  /채팅방 가져오기 
    useEffect(() => {
        const loadChats = async () => {
            try {
                const data = await fetchChatsByRoom();
                console.log('roomsAndChats의 값은?', data);
                setRoomsAndChats(data);
            } catch (error) {
                console.error('Error loading chats: ', error);
            }
        };
        loadChats();
    }, [])
	
	위와 같이 setRoomsAndChats(data) 즉 roomsAndChats라는 데이터로 자식 컴포넌트인 ProfileContainer에 전달됩니다.
	
---------------------------------------------------------------------------------------------------------------------------

2. ProfileContainer 컴포넌트의 서치바를 이용해 user를 검색하면 users와 searchedLastMessage라는 배열들을 값으로 내보내는데 
이 값들을 PreviewCard 컴포넌트에 담아서 화면에 보여줍니다.

위의 조건으로 PreviewCard를 생성 
{searchbarActive && searchedUserData && (
                        <>
                            <div style={{ textAlign: 'center', marginBottom: '7px', fontSize: 'small', color: 'gray' }}>friends</div>
                            {searchedUserData.users.filter(friend => friend.name !== user.name).map((friend) => {
                                console.log('프리뷰카드에 사용할 프렌드 아이디는?!', friend._id); // friend._id 값 콘솔에 출력
                                return (
                                    <PreviewCard
                                        key={friend._id}
                                        friendId={friend._id}
                                        friend={friend}
                                        handleUserClick={handleUserClick}
                                        searchbarActive={searchbarActive}
                                    />
                                );
                            })}
                        </>
                    )}
		
searchedUserData는 아래와 같이 useQuery를 사용하여 데이터를 가져옵니다. 		

// useQuery 사용
    const { data: searchedUserData, isLoading, isError } = useQuery(
        {
            queryKey: ['searchedUserData', query], // 쿼리 키
            queryFn: () => searchUsers(query),    // 쿼리 함수
            enabled: query.length > 0,            // 쿼리가 있을 때만 실행
        }
    );

이 요청을 처리하는 서버 코드: 
//유저 정보 가져오기 유저찾기 친구추가하기
    userController.findUsers = async(req, res) => {
        try{
            const loggedInUserId = req.userId;

            //쿼리받아옴 (유저가 검색한 이름 혹은 이메일)
            const { query } = req.query;
            console.log('유저 찾기 쿼리: ', query);
            if(!query){
                return res.status(400).json({ message: 'Please provide a search term'});
            }
            //쿼리로 유저 찾기 
            let users;
            try {
                //이름으로만 찾기
                users = await User.find({ name: { $regex: new RegExp(query, 'i')} });
            } catch (dbError) {
                console.error('Database query error: ', dbError); // Log database error
                return res.status(500).json({ message: 'Database query failed', error: dbError.message });
            }
            console.log('검색어로 찾은 유저(들): ', users);
            if(users.length === 0){
                return res.status(400).json({message: 'No users found'});
            }

            //유저 사이에 존재하는 채팅창 찾기기
            //1. users의 아이디 추출 
            const userIds = [loggedInUserId, ...users.map((user) => user._id)]; // ['로그인한 유저 아이디디','유저아이디1', '유저아이디2','유저아이디3'...]

            //2.로그인한 유저아이디랑 쿼리로 찾은 유저들의 아이디가 memebers로 들어간 채팅 창을 다 가지고 옴 
            const rooms = await Room.find({ members: {$all: userIds} })

            let searchedLastMessage = [];

            if (rooms && rooms.length > 0) {
                searchedLastMessage = await Promise.all(
                    rooms.map(async (room) => {
                        // Check if there are any messages in the room
                        const lastMessageIdx = room.chats.length > 0 ? room.chats[room.chats.length - 1] : null;

                        if (lastMessageIdx) {
                            // Fetch the last message from the Chat collection
                            const lastMessage = await Chat.findById(lastMessageIdx);
                            return lastMessage; // Return the last message object
                        }

                        return null; // If no messages exist in the room, return null
                    })
                );
            }

        console.log('Last messages for rooms: ', searchedLastMessage);
        res.status(200).json({ users, searchedLastMessage });
        }catch(e){
            res.status(500).json({message: e.message});
        }
    };

마지막으로 

3.searchedUserData 안에 searchedLastMessage가 있는 경우 다음과 같은 props들을 PreviewCard컴포넌트로 전달해 화면에 업데이트 하도록 합니다.

{searchbarActive && searchedUserData && searchedUserData.searchedLastMessage.length > 0 &&(
                        <>
                            <div style={{ textAlign: 'center', marginBottom: '7px', fontSize: 'small', color: 'gray' }}>chats</div>
                            {searchedUserData.searchedLastMessage.map((lastMessage) => {
                                console.log("lastMessage when map()", lastMessage);  // Log each `lastMessage` to the console
                                return (
                                    // <p>lastMessage.chat={lastMessage.chat}</p>
                                    <PreviewCard
                                        key={lastMessage._id}
                                        id={lastMessage.room}
                                        lastMessage={lastMessage}  // Passing the `lastMessage` to PreviewCard
                                        handleChatClick={handleChatClick}
                                    />
                                );
                            })}
                        </>
                    )}


부모컴포넌트에서는 상황에 맞게 다른 props들을 넘겨주면서 PreviewCard를 렌더링 할 수 있도록 했지만 
결국 이 모든 props들이 자식 컴포넌트인 PreviewCard 컴포넌트에 한 번에 전달되면 부모 컴포넌트에 정의해 두었던 조건들과 상관없이 항상 렌더링 되고 
정작 필요할 때는 렌더링 되지 않는 에러를 경험하게되었습니다. 

하지만 3가지 경우 모두 동일 한 디자인 PreviewCard를 사용하기 때문에 PreviewCard 안에서 조건물을 이용해 보여주려고 했지만 한계가 있는것 같아서 결국 
같은 내용의 컴포넌트를 3가지로 나눠서 각 각 PreviewCardSearchedChat, PreviewCard, PreviewCardDefault 라는 이름으로 만들어 3가지의 다른 조건에 맞게 props를 넘겨주고 
3가지 다른 컴포넌트에서 이를 실행할 수 있도록 만들었습니다.


[해결]
생각 보다 너무 간단했고 ㅠㅠ 이제서라도 그 방법을 알게되어 정말정말 다행이라는 생각밖엔 들지 않을정도... ㅠㅠ 
해결 방법을 바로 부모컴포넌트에서 type을 지정하여 props의 일부로 자식 컴포넌트에게 넘겨주는 것이고
자식컴포넌트는 이 type을 props로 넘겨받아 switch(type){ case "타입1" : return(); case "타입2" : return(); ... default: return null; }으로 해결하는거 였음
충격 그 자체다. 계속 해서 꼬아서 생각을 하다 보니 결국 가장 기본적인 것을 놓치게 되는 상황에 이르렀단걸 또 한 번 느끼게 되었습니다..

[해결방법과 관련된 코드들]
{/* ProfileContainer에서 PreviewCard 렌더링 수정 - 타입추가 */}
                    {searchbarActive && searchedUserData && (
                        <>
                            <div style={{ textAlign: 'center', marginBottom: '7px', fontSize: 'small', color: 'gray' }}>friends</div>
                            {searchedUserData.users.filter(friend => friend.name !== user.name).map((friend) => {
                                console.log('프리뷰카드에 사용할 프렌드 아이디는?!', friend._id); // friend._id 값 콘솔에 출력
                                return (
                                    <PreviewCard
                                        key={friend._id}
										type="searched"
                                        friendId={friend._id}
                                        friend={friend}
                                        handleUserClick={handleUserClick}
                                        searchbarActive={searchbarActive}
                                    />
                                );
                            })}
                        </>
                    )}

                    {searchbarActive && searchedUserData && searchedUserData.searchedLastMessage.length > 0 &&(
                        <>
                            <div style={{ textAlign: 'center', marginBottom: '7px', fontSize: 'small', color: 'gray' }}>chats</div>
                            {searchedUserData.searchedLastMessage.map((lastMessage) => {
                                console.log("lastMessage when map()", lastMessage);  // Log each `lastMessage` to the console
                                return (
                                    // <p>lastMessage.chat={lastMessage.chat}</p>
                                    <PreviewCard
                                        key={lastMessage._id}
										type='searchedChat'
                                        id={lastMessage.room}
                                        lastMessage={lastMessage}  // Passing the `lastMessage` to PreviewCard
                                        handleChatClick={handleChatClick}
                                    />
                                );
                            })}
                        </>
                    )}


                    
                    




                {/* 로그인한 유저가 기존에 들어가 있던 채팅방 - 잘 나오고 있기때문에 건들지 말기 */}
                {!searchbarActive && combined && combined.length > 0 && (
                    <>
                        {combined.map((roomWithChat) => (
                            <PreviewCard
                                key={roomWithChat._id}
								type="start"
                                id={roomWithChat._id}
                                profileImage={roomWithChat.chat.profileImage}
                                name={roomWithChat.chat.name}
                                chat={roomWithChat.chat.content}
                                createdAt={roomWithChat.chat.createdAt}
                                handleChatClick={handleChatClick}
                                searchbarActive={searchbarActive}
                            />
                        ))}
                    </>
                ) }
				
				
// PreviewCard 컴포넌트에서 switch문을 이용해서 type에 맞는 렌더링 하도록 수정 
const PreviewCard = ({ type, id, profileImage, name, chat, createdAt, friendId, friend, lastMessage, handleChatClick, searchbarActive }) => {
  switch (type) {
    case "start":
      return (
        <div onClick={() => handleChatClick(id)}>
          <img src={profileImage} alt="Profile" />
          <div>{name}</div>
          <div>{chat}</div>
          <div>{new Date(createdAt).toLocaleString()}</div>
        </div>
      );
    case "searched":
      return (
        <div onClick={() => handleUserClick(friendId)}>
          <img src={friend.profileImage} alt="Friend" />
          <div>{friend.name}</div>
        </div>
      );
    case "searchedChat":
      return (
        <div onClick={() => handleChatClick(id)}>
          <div>{lastMessage.chat}</div>
          <div>{new Date(lastMessage.createdAt).toLocaleString()}</div>
        </div>
      );
    default:
      return null;
  }
};



8.
[문제]
-useQuery를 사용하는데 데이터를 가지고 오는 속도가 지나치게 느림 (30초 이상)
-지속적으로 서버 500에러 발생 

[해결]
-Network에서 확인했을 때 'fetch-one-user/null' 즉 넘겨줘야 하는 값이 null로 나온다 라는 에러가 있었음 
-http 요청하는곳을 확인해보니 fetch-one-user/${id} 로 설정 되어있었고 (클릭한 특정 유저의 id), 서버에서는 fetch-one-user/:id로 설정되어 있음 
-즉 문제는 넘겨줘야하는 id값을 useQuery를 사용할 때 쓰지 않았기 때문에
- 클릭한 유저의 id는 clickedUser 라는 변수에 보관되어 있고 이는 마찬가지로 http 요청을 보내는 함수의 매개변수로 전달이 되기도 한다 
- id나 쿼리 처럼 넘겨줘야 하는 값은 queryKey:['쿼리키', 넘겨줄 값] 으로 설정해주면 queryFn 함수가 호출될 때 알아서 아 넘겨줄 값이 있는가보다 하고 넘겨줌   
i.e
http 요청 함수 
function 변수명 (id){
    const response = await api.get(`http://localhost:5001/api/fetch-one-user/${id}`, {... 생략})
}

useQuery 로 data fetching
const { data, isLoading, isError } = useQuery({
    queryKey: ['쿼리키', {id: clickedUser}],
    queryFn: () => 변수명(clickedUser)
})


9.
[문제]
mongoose db compass 에서 삭제한 데이터가 실제 프로젝트의 서버에서는 삭제되지 않음 
왜그런건진 모르겠음..? 

[해결] 
mongoose.connect하는 시기에 불필요한 데이터를 찾아서 삭제함 

기존코드 
mongoose.connect(process.env.DB, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
}).then(() => console.log('connected to db'));

module.exports = app

불필요한 데이터를 삭제하는 코드 
// 데이터베이스 연결
mongoose.connect(process.env.DB, { useNewUrlParser: true, useUnifiedTopology: true }) => 여기 까지기존 연결 코드와 동일
    .then(() => {
        console.log('connected to db');
        
        // 앱 시작 시점에 해당 ObjectId를 가진 데이터를 삭제하는 쿼리 실행
        const chatIdToRemove = '67638f1738f1324752980516';  // 삭제할 ObjectId

        // chats 배열에서 해당 ObjectId를 자동으로 제거
        Room.updateMany(
            { chats: new mongoose.Types.ObjectId(chatIdToRemove) },  // chats 배열에 해당 ObjectId가 포함된 모든 문서 찾기
            { $pull: { chats: new mongoose.Types.ObjectId(chatIdToRemove) } }  // 해당 ObjectId를 chats 배열에서 제거
        )
        .then(result => {
            console.log(`Successfully removed chat ID ${chatIdToRemove} from chats arrays.`);
        })
        .catch(err => {
            console.error('Error removing chat ID:', err);
        });
    })
    .catch(err => console.error('MongoDB connection error:', err));


10.
[가끔씩 보이는 .populate 메소드는 무엇?]------------------------------------------------------
populate는 MongoDB에서 참조 관계를 가진 데이터를 자동으로 불러오는 역할을 합니다.       

i.e                                                                                       
rooms 필드가 이미 user 컬렉션 안에 존재한다면,                                                 
user.rooms는 Room 컬렉션에서 해당 ObjectId들만 저장하고 있을 것입니다.                          
여기서 populate를 사용하면, user.rooms에 저장된 Room 객체들의 전체 데이터를 불러올 수 있습니다.
((사용하는 법:))-----------------------------------------------
const user = await User.findById(userId).populate('rooms');  |
console.log(user.rooms);                                     |
--------------------------------------------------------------

전체 객체를 reference로 사용하는게 아니라 객체 중에서 필요한 필드만 가져와서 사용하고 싶을 때
const chats = await Chat.find({
  '_id': { $in: chatIdsList },
  ...chatsQuery,  // leftMember가 있으면 timestamp 필터링이 적용됨
})
.populate('sender', 'name profileImage')  // Populate only selected fields of sender
.populate('recipient', 'name profileImage'); // Populate only selected fields of recipient



11.
[문제]
2개의 array list 값 중 일치하는 값이 있는지 확인하기 
[해결1] - some 을 사용해야 한다 
searchedUserData.users.some(friend =>
    searchedUserData.searchedLastMessage.some(
        lastMessage => lastMessage.sender.name === friend.name || lastMessage.recipient.name === friend.name
    )

[해결2] filter, include 활용
const commonRooms = friend.rooms.filter(room => user.rooms.includes(room));


12.
[문제]
PreviewCard 가장 상단에 
<div className='chat-room-preview-card' onClick={() => handleChatClick(lastMessageRoomId)}>
그리고 chat-room-preview-card 안쪽으로 들어가는 div태그에 
<div 
    className='x-box'
    onClick={() => handleDeleteSelectedChat(lastMessageRoomId)}    
>
    x
</div>
를 정의, x를 클릭하면 이벤트 버블링이 발생하여 상단 부모태그에 존재하는 onClick={() => handleChatClick(lastMessageRoomId)}이 호출된다
[해결]
x 버튼에서 클릭 이벤트가 부모로 전파되지 않도록 이벤트 버블링을 막아야 합니다. 이를 위해 e.stopPropagation() 메서드를 사용할 수 있습니다.
(e) => e.stopPropagation 


[문제 및 해결]
//유저들이 속해 있는 room 찾아서 room의 아이디를 user.rooms 필드안에 저장 
    for (const user of users) {
        const room = await Room.findById(user._id);
        user.rooms.push(room._id);
        await user.save();
    }


[문제-채팅삭제]--------------------------------------------------------------------
구현부 : 
max-lucy가 대화를 함 
max가 나감 

max로 로그인하면 default PreviewCard 가 보이지 않음 
lucy를 검색하면 lucy의 프로필 카드가 나옴 

lucy로 로그인하면 default에 max와 나눈 대화가 뜸 
max를 검색하면 lucy가 max와 나눈 대화가 뜸  
----------------------------------------------------------------------------------


[해결1]
chatController.deleteSelectedChatRoom에서 기존의 filter()를 사용하는 방법을 수정한다 
deleteSelectedChatRoom 함수가 호출되면 해당 room.leftMember = userId 를 넣고 
await room.save() 로 업데이트 된 부분을 저장해준다.

room.js 스키마에 채팅을 떠난 멤버의 id와 timestamp를 저장
leftMembers: [
            {
                type: mongoose.Schema.ObjectId,
                ref: "User",
                timestamp: Date, // 나간 시간을 기록
            }
        ]
-------------------------------------------------------------------------
[해결2]
chatController.getChatMessagesByRoom에서 rooms 를 가지고 오는 방법 수정 

    let rooms = await Room.find({members : userId});
	rooms = rooms.filter(room => !room.leftMembers.some(leftMember => leftMember.toString() === userId))

1.userId 가 members필드의 값으로 들어간 room 객체들을 모두 rooms라는 배열에 모아둔 뒤에 
2.room 객체의 leftMembers 필드 값으로 userId 있는 room 객체들은 rooms 배열에서 제외시킨다.
-------------------------------------------------------------------------
[해결3]
userController.findUsers에서 rooms를 가지고 오는 방법 수정 (해결2와 동일한 방법 이용용)

const userIds = [loggedInUserId, ...users.map((user) => user._id)]; // ['로그인한 유저 아이디','유저아이디1', '유저아이디2','유저아이디3'...]

let rooms = await Room.find({ members: {$all: userIds} })
rooms = rooms.filter(room => !room.leftMembers.some(member => member.toString() === loggedInUserId));


로그인한 유저아이디랑 쿼리로 검색한 유저들의 아이디가 memebers로 들어간 room 객체들은 rooms []에 저장 
room 객체들 중 leftMembers의 값으로 로그인한 유저의 아이디가 있는경우를 제외하고 남은 room객체들을 모아 rooms에 저장 

[문제]
기존 room의 leftTime 필드 배열에는 각 유저가 대화를 나갈 때마다 timestamp를 저장해서 
2번이상 room을 나간 user가 다시 room에 들어왔을 때 메세지를 전체 조회하게 된다 -> 에러. 
[해결]
1. leftTime 중복처리
 -filter() 사용으로 같은 userId에 대한 기록을 모두 삭제한 후 최신 timestamp만 남긴다 
 -최신 timestamp를 추출하기 위해 sort() 내림차순으로 정렬 -> 첫번째 값을 선택한다
2. chatsQuery 수정:
 -leftMember.timestamp가 존재할 경우, createdAt을 필터링하여 퇴장 이후의 채팅만 조회
3. room.save():
 -room을 갱신한 후 저장하여 변경된 leftTime 배열을 DB에 반영합니다.


 --------------------------------------------------------------------
         //만약 유저가 이전에도 방을 떠난적이 있다면 
        if(leftMember){
          const latestLeftTime = room.leftTime.filter(member => member.userId.toString() === userId).sort((a, b) => b.timestamp - a.timestamp)[0];

          room.leftTime = room.leftTime.filter(member => member.userId.toString() !== userId);
          room.leftTime.push(latestLeftTime);
  
        }

        await room.save();

        //leftMember가 존재하고 timestamp 값이 있으면
        if (leftMember && leftMember.timestamp) {
          chatsQuery.createdAt = { $gte: leftMember.timestamp }; //퇴장한 멤버 이후의 채팅만 조회하도록 createdAt 필터를 추가합니다.
        }
-----------------------------------------------------------------------

[문제]
websocket을 이용해서 유저 사이의 실시간 통신은 가능하지만
실시간으로 전송되는 메세지를 패칭하는 상태관리를 하고 있지않기 때문에 
ui 업데이트가 성공적으로 이뤄지지 않고있다

<Chat> 
연결이 되면 메세지를 불러오기 위해 websocket의 message 이벤의 결과를 ui에 반영한다
 useEffect(() => {
        socket.on('message', (message) => {
            setMessageList((prevState) => {
                return Array.isArray(prevState) ? [...prevState, message] : [message];
            });
        });

        return () => {
            socket.off('message');
          };
    }, []);

실시간으로 소통하기 위해 websocket.emit을 통해 이벤트 발생시킴 
    const sendMessage = (e) => {
        socket.emit("sendMessage", { message, recipient, sender }, (response) => {
            if (response.ok) {
                setMessage('');  // 성공 후 입력 필드 비우기
            } else {
                alert(response.error || '메시지 전송 실패');
            }

        });
    };
	
<>

양방향 통신을 위한 웹소켓 이벤트 
        socket.on("sendMessage", async ({ message, recipient, sender }, cb) => {
            console.log('받는사람', recipient);
            /*
            recipient {
            name: 'lucy',
            profileImage: '/uploads/1733101504620-lucy.png',
            _id: '674d075dbce09ae0fee729ae',
            online: false
            }
            */ 
            if(!recipient){
                return cb({ ok: false, error: 'Recipient is not existing' });
            }
            const user = await userWsController.findUserById(sender.id);

            try {
                // 채팅 메시지 저장
                const newMessage = await chatController.saveChat({ message, recipient, sender }, user);
                // 새 메시지 전송
                io.emit('message', newMessage); 
                cb({ ok: true }); // 클라이언트에게 성공 응답
            } catch (error) {
                cb({ ok: false, error: error.message }); // 실패 시 에러 응답
            }
        });
        
        
    // 클라이언트가 보낸 메시지를 수신 하는 역할 - 만약 없으면 양방향 통신에 문제가 생기므로 채팅을 할 수 없어진다. 
     socket.on('message', (message) => {
        console.log('Received message:', message);
        // Display the message in the UI
    });
	
 

[해결]
각 채팅방의 대화(chat객체들)를 fetching 해오는 방식을 tanstack 쿼리를 사용 
 const {data: roomsAndChats} = useQuery({
    queryKey: ['roomsAndChats'],
    queryFn: fetchChatsByRoom,
    initialData: [] //이니셜데이터 설정을 해두지 않으면 오류남
});

기존의 sendMessage 함수안에 선언된 socket.emit('sendMessage' ...) 이벤트를 
useMutatiom을 이용해 처리함 
-> 새로운 챗이 업데이트 되면 invalidateQueries를 이용해서 데이터를 새로 캐싱하고 
전달된 새로운 데이터가 실시간으로 ui에 업데이트 될 수 있도록 함 


[기존 코드 (useMutation 사용 전전)]
const sendMessage = (e) => {
    e.preventDefault();
    //채팅창 상대방 정하기 
    let recipient;

    if (messageList) {
        recipient = chatPartner;
    }

    if(data){ //data 는 clickedUser를 의미 -> 지금은 data가 하나 밖에 없음
        recipient = {
            name: data.name,
            profileImage: data.profileImage,
            _id: data._id,
            online: data.online
        }
    }
    console.log('보내는 사람은?', recipient);
    const sender = user;

    // 유효성 검사 - recipient와 sender가 잘 설정되어 있는지 확인
    if (!sender) {
        alert("Sender information is missing");
        return;
    } else if (!recipient) {
        alert("Recipient information is missing");
        return;
    }

    socket.emit("sendMessage", { message, recipient, sender }, (response) => {
        if (response.ok) {
            setMessage('');  // 성공 후 입력 필드 비우기
        } else {
            alert(response.error || '메시지 전송 실패');
        }

    });
};

[ useMutation 사용 후 ]
const sendMessage = useMutation({
        mutationFn: async({message, recipient, sender}) => {
            return new Promise((resolve, reject) => {
                socket.emit('sendMessage', {message, recipient, sender}, (response) => {
                    if(response.ok){
                        resolve(response);
                    }else{
                        reject(response.error || '메세지 전송 실패');
                    }
                });
            });
        },
        onSuccess: () => {
            queryClient.invalidateQueries('roomsAndChats');
            setMessage('');
        },

    });

    const handleSendMessage = (e) => {
        e.preventDefault();
        //채팅창 상대방 정하기 
        let recipient;

        if (messageList) {
            recipient = chatPartner;
        }

        if(data){ //data 는 clickedUser를 의미 -> 지금은 data가 하나 밖에 없음
            recipient = {
                name: data.name,
                profileImage: data.profileImage,
                _id: data._id,
                online: data.online
            }
        }
        const sender = user;

        // 유효성 검사 recipient와 sender 유/무 확인인
        if (!sender) {
            alert("Sender information is missing");
            return;
        } else if (!recipient) {
            alert("Recipient information is missing");
            return;
        }

        sendMessage.mutate({message, recipient, sender});
    };


---

ChattingContainer 컴포넌트에서 ui업데이트 관련 문제 
[문제]
multiChatPartner 리스트에 있는 user의 profileImage를 div 태그에 담아 보여주는데 빈 div가 화면에 나옴 

{/* header - 기존 채팅의 유무에 따라 */}
    <div className='chatroom-header'>
        <div className='userfriend-img-container'>
            <div className='chat-userfriend-img'>
                {clickedUserData && !messageList && !multiChatPartner && // 로그인한 유저-클릭한 유저 간의 채팅이 없는 상태
                        <img
                            className='img-rsc'
                            src={`http://localhost:5001${clickedUserData.profileImage}`}
                            alt='user profile clicked'
                        />
                }
                {messageList && messageList.length > 0 ? ( //기존 채팅 프리뷰 카드를 클릭하면 챗 파트너들의 사진을 보여줍니다.
                        <img
                            className='img-rsc'
                            src={`http://localhost:5001${chatPartner.profileImage}`}
                            alt='chatting partner'
                        />
                ) : null}
            </div>
            

        {multiChatPartner && multiChatPartner.users.length > 0 &&
            multiChatPartner.users
                .map((chatPartner) => (
                    chatPartner.profileImage ? (
                        <div className='chat-userfriend-img' key={chatPartner._id} >
                            <img
                                className="img-rsc"
                                src={`http://localhost:5001${chatPartner.profileImage}`}
                                alt={`user profile clicked ${chatPartner.name}`}
                            />
                        </div>
                    ) : null // profileImage가 없으면 null 반환
                ))
        }    
        </div>
        <div>chatting room name</div>
    </div>

[해결]
multiChatPartner 를 ui 업데이트할 때 빈 값인 div를 생성해내는게 아닌 
{clickedUserData && !messageList && !multiChatPartner && // 로그인한 유저-클릭한 유저 간의 채팅이 없는 상태
                        <img
                            className='img-rsc'
                            src={`http://localhost:5001${clickedUserData.profileImage}`}
                            alt='user profile clicked'
                        />
                }
                {messageList && messageList.length > 0 ? ( //기존 채팅 프리뷰 카드를 클릭하면 챗 파트너들의 사진을 보여줍니다.
                        <img
                            className='img-rsc'
                            src={`http://localhost:5001${chatPartner.profileImage}`}
                            alt='chatting partner'
                        />
에 해당하는 div가 null 값으로 찍혀나오는 것이였음 

그래서 아래와 같이 수정해 주었음 

            {/* header - 기존 채팅의 유무에 따라 */}
            <div className='chatroom-header'>
                {/* multiChatPartner가 존재하고, multiChatPartner.users 배열이 비어있지 않은 경우만 렌더링 */}
                {multiChatPartner && multiChatPartner.users.length > 0 ? (
                    <div className='userfriend-img-container'>
                        {multiChatPartner.users.map((chatPartner) => (
                            chatPartner.profileImage ? (
                                <div className='chat-userfriend-img' key={chatPartner._id}>
                                    <img
                                        className="img-rsc"
                                        src={`http://localhost:5001${chatPartner.profileImage}`}
                                        alt={`user profile clicked ${chatPartner.name}`}
                                    />
                                </div>
                            ) : null // profileImage가 없으면 null 반환
                        ))}
                    </div>
                ) : <>
                    {/* 그 외의 기존 코드 */}
                    <div className='userfriend-img-container'>
                        <div className='chat-userfriend-img'>
                            {clickedUserData && !messageList && !multiChatPartner &&
                                <img
                                    className='img-rsc'
                                    src={`http://localhost:5001${clickedUserData.profileImage}`}
                                    alt='user profile clicked'
                                />
                            }
                            {messageList && messageList.length > 0 ? (
                                <img
                                    className='img-rsc'
                                    src={`http://localhost:5001${chatPartner.profileImage}`}
                                    alt='chatting partner'
                                />
                            ) : null}
                        </div>
                    </div>
                </>}
                                



                <div>chatting room name</div>
            </div>

multiChatPartner가 존재하고, multiChatPartner.users 배열이 비어있지 않은 경우만 렌더링하고 그렇지 않은경우 
기존 코드를 이용하여 clickedUserData 존재할 때 혹은 messageList가 존재할 때 chatPartner의 profileImage 가 나오도록 함 


[문제]
A-B-C 라는 유저가 있다고 가정했을 때 C-A-B 순으로 유저들을 추가 했다. 
하지만 불러온 유저 객체의 순서는 계속해서 A-B-C 순으로 유지되고 있다. 
유저 객체를 불러올 때 클릭한 순서대로 유저의 객체를 가지고 오고 싶을 때 어떻게 하면 좋을까?

[해결]
서버에 코드를 추가하여 유저를 클릭한 순서대로 객체를 불러온다 

추가 및 수정된 부분 : 
fetchMultipleUsers
    //idsArray 순서대로 유저 객체를 정렬 
            const sortedUsers = idsArray.map(id => users.find(user => user._id.toString() === id));
    
            // 유저 정보 반환
            return res.status(200).json({ users: sortedUsers });


[previewCard 스위치문 대체 - mapping]
// PreviewCard.jsx
const renderTypes = {
  start: (props) => <StartPreview {...props} />,
  friendList: (props) => <FriendListPreview {...props} />,
  searched: (props) => <SearchedPreview {...props} />,
  searchedChat: (props) => <SearchedChatPreview {...props} />
};

const PreviewCard = ({ type, ...props }) => {
  const PreviewComponent = renderTypes[type] || null;

  return (
    <div className='chat-room-preview-card'>
      {PreviewComponent ? <PreviewComponent {...props} /> : null}
    </div>
  );
};


// StartPreview.jsx
const StartPreview = ({ profileImage, name, chat, date, handleChatClick, id }) => (
  <div onClick={() => handleChatClick(id)}>
    <div className='chat-room-preview-layout1'>
      <div className='chat-room-preview-profile-img'>
        <img src={`http://localhost:5001${profileImage}`} alt='profile' className='img-rsc' />
      </div>
      <div className='chat-room-preview-contents'>
        <div className='preview-contents-name'>{name}</div>
        <div>{chat}</div>
      </div>
      <div className='chat-room-preview-more'>
        <div className='preview-contents-date'>{date}</div>
      </div>
    </div>
  </div>
);

// Other components for `friendList`, `searched`, and `searchedChat` would follow a similar pattern



[가장 가장 가장 큰 문제]
비동기 방식을 활용해 서버로 부터 데이터를 가져올 때 
데이터를 아직 받아오지 않았는데 리액트의 jsx가 이미 실행되어 버려서 
ui는 업데이트되나 내용이 undefined로 업뎃 되는 경우가 너어어어무 많다 

비동기 방식으로 데이터를 가져와 ui를 업데이트 할 때 데이터가 아직 불러와지지 않았다면 ui를 업데이트 하지 않도록 하는 조치가 너무 필요함 ㅅㅂ

[문제]
ChattingContainer header에 들어갈 상대방 프로필사진 문제 
기존 대화 클릭 - 상대방 프사 잘 나옴 
대화 하기 위해서 상대방 프사 클릭 - 프사 잘 나옴 
2번 실행 후 메세지 보내기 - 
{(messageList && messageList.length > 0) && chatPartner ? (
    <img
        className='img-rsc'
        src={`http://localhost:5001${chatPartner? chatPartner.profileImage : clickedUserData.profileImage}`}
        alt='chatting partner'
    />
) 
여기서 chatting partner 가 값으로 나옴 

[해결]
문제는 메세지를 보내는 과정에서 상태 관리되고 있는 chatPartner를 업데이트 시켜야 화면에 잘 나올 수 있음 
handleSendMessage 함수 가장 아래부분에 recipient 와 sender를 정하는 식 다음에 
정해진 recipient를 partner로 업데이트 해주기 위해 setPartner(recipient)를 더해줌 
이렇게 메세지를 새로 보낸 직 후에도 chatPartner의 사진이 잘 나오게 됨
                

[문제]
1:n 그룹채팅을 하기 위해서 recipient를 설정하는 코드를 짰는데 n에 해당하는 데이터인 multiChatPartner.users.length >= 1 를 만족했음에도 불구하고 
계속해서 1:1 의 clickedUserData를 recipient로 설정

코드:
        let recipient;

        if (messageList) {
            recipient = chatPartner;
        } else if (clickedUserData){ //&& !multiChatPartner
            recipient = {...};
        } else if (multiChatPartner && multiChatPartner.users && multiChatPartner.users.length >= 1) {
            recipient = multiChatPartner.users.map((user) => ({...}));
            console.log('recipient은 잘 설정되었나?:', recipient);  // recipient는 배열로 전송


[해결]
위의 코드의 경우 messageList가 존재하지 않고 clickedUserData가 존재하지 않는 상태에서만 multiChatPartner.users.length >= 1를 확인하는 
방식으로 넘어가게 설정되어 있다. 하지만 여러명의 대화 상대를 설정하기 위해선 previewCard를 클릭하여 handleUserClick()을 호출하게 되고 
그 결과로 clickedUserData가 존재하게 된다. 

그래서 이 두 가지 코드의 순서를 바꿔줘야지만 1:1, 1:n 채팅 시 상대방의 data를 성공적으로 fetching 할 수 있게된다.

코드:
        let recipient;

        1. if (messageList) { 
            recipient = chatPartner;
        2. }else if (multiChatPartner && multiChatPartner.users && multiChatPartner.users.length >= 1) {
            recipient = multiChatPartner.users.map((user) => ({...}));
            console.log('recipient은 잘 설정되었나?:', recipient);  // recipient는 배열로 전송
        3. } else if (clickedUserData){ 
            recipient = {...};
           }
        
        1
        messageList로 이전의 대화 유무를 알 수 있다. 
            -기존에 대화가 존재하면 대화를 불러온다.
        2
        multiChatPartner.users.length >= 1
            -대화 존재하지 않다. 채팅방에 여러명의 상대를 선택했다.

        3
        clickedUserData
            기존 대화가 존재하지 않고, 채팅방에 여러명의 상대를 선택하지도 않았다. 하지만 1명의 상대를 선택했다
    
    라는 의미로 정리 해볼 수 있다

[문제]
깃허브 커밋 관련 
진짜 조심해야 되는거: 
서버/uploads 파일안에 저장해두던 profileImage를 삭제했음. 
-> 깃허브에서만 삭제되는거 아니고 프로젝트에서 아예 삭제됨 
조심하거라..



[문제]
채팅방을 찾아야 하는데 a와 b유저 둘만 있는 채팅방을 찾아야함 (두 유저와 다른 유저들이 함께 포함된 방은 의미x)
-> 2가지 조건을 이용해서 원하는 데이터를 찾아와야함.

[해결]
let room = await Room.findOne({
    members: { $all: membersIds }, // 모든 membersId가 포함된 room 찾기
    $expr: { $eq: [{ $size: "$members" }, membersIds.length] } // members의 크기가 정확히 일치하는지 확인
    });


[주의]
리스트.map( 객체 => )컴포넌트 렌더링 중 useState()를 이용해 상태업데이트 할 수 없다 
[해결]
let 변수로 선언

[문제]
3가지 값 true,false,undefind를 해결하는 삼항 연산자 
[해결]
{currentAddState !== undefined ? ( currentAddState ? "delete" : "add") : null}
clickedUser.length === undefind : null
clickedUser.length > 0 && clickedUser.map( c => c === f._id ) : true -> delete
clickedUser.length > 0 && clickedUser.map( c => c !== f._id ) : false -> add